---
alwaysApply: true
---

# FinCRM 项目开发规范

## 语言规范

### UI 界面文本
- ✅ **所有用户可见的界面文本必须使用英文**
  - 按钮文本：Login, Register, Submit, Cancel, Save, Delete 等
  - 表单标签：Email, Password, First Name, Last Name 等
  - 页面标题：Dashboard, User Profile, Settings 等
  - 提示信息：Success, Error, Warning 等
  - 表格标题：Name, Status, Created At, Actions 等

### 代码注释
- ✅ **所有代码注释必须使用中文**
  - 函数说明、参数说明、返回值说明用中文
  - 复杂逻辑的解释用中文
  - TODO、FIXME 等标记用中文描述
  - 文件头部说明用中文

### 示例

**正确示例** ✅：
```typescript
/**
 * 用户登录函数
 * @param email - 用户邮箱
 * @param password - 用户密码
 * @returns 返回登录结果
 */
async function login(email: string, password: string) {
  // 验证邮箱格式
  if (!isValidEmail(email)) {
    return { error: "Invalid email format" }  // UI 显示用英文
  }
  
  // 调用 Supabase 认证
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })
  
  if (error) {
    return { error: "Login failed" }  // UI 显示用英文
  }
  
  return { success: true, message: "Login successful" }
}
```

**错误示例** ❌：
```typescript
// Bad: UI 文本用中文，注释用英文
async function login(email: string, password: string) {
  // Validate email format
  if (!isValidEmail(email)) {
    return { error: "邮箱格式错误" }  // ❌ UI 不应该用中文
  }
  return { success: true, message: "登录成功" }  // ❌ UI 不应该用中文
}
```

## 技术栈规范

### Next.js (App Router)
- 使用 App Router（不是 Pages Router）
- 服务器组件优先，需要交互时使用 "use client"
- 使用 TypeScript，所有文件必须有类型定义

### Supabase 集成
- 使用 Cookie-based 认证（不使用 localStorage）
- 客户端：使用 `createClient()` from `@/lib/supabase/client`
- 服务器端：使用 `createClient()` from `@/lib/supabase/server`
- 启用 Row Level Security (RLS)

### UI 组件
- 使用 shadcn/ui 组件库
- 使用 Tailwind CSS 进行样式定义
- 响应式设计优先（移动端优先）

### 代码风格
- 使用 ES6+ 语法
- 优先使用 async/await 而不是 Promise.then()
- 组件使用函数式组件（不使用 Class 组件）
- Props 必须定义 TypeScript 接口

## 文件命名规范

- 组件文件：`kebab-case.tsx` (例如：`user-profile.tsx`)
- 工具函数：`kebab-case.ts` (例如：`format-date.ts`)
- 类型定义：`kebab-case.ts` (例如：`user-types.ts`)
- 页面路由：`page.tsx` (App Router 约定)

## 错误处理规范

- 所有异步操作必须有错误处理
- 错误信息对用户显示时用英文
- 错误日志可以用中文注释说明错误原因
- 使用 try-catch 或 error 返回值

## 安全规范

- 永远不要在客户端存储敏感信息
- 使用环境变量存储密钥
- API 调用使用 Supabase RLS 保护
- 用户输入必须验证和清理

## 示例：完整的组件

```typescript
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { useAuth } from "@/components/auth-provider"

interface LoginFormProps {
  onSuccess?: () => void
}

/**
 * 登录表单组件
 * 提供邮箱和密码登录功能
 */
export function LoginForm({ onSuccess }: LoginFormProps) {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [error, setError] = useState<string | null>(null)
  const { login, isLoading } = useAuth()

  /**
   * 处理表单提交
   */
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    // 清除之前的错误
    setError(null)
    
    // 调用登录函数
    const result = await login(email, password)
    
    if (result.success) {
      // 登录成功，执行回调
      onSuccess?.()
    } else {
      // 显示错误信息（英文）
      setError(result.error || "Login failed")
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {/* 邮箱输入框 */}
      <div>
        <label htmlFor="email" className="text-sm font-medium">
          Email
        </label>
        <Input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Enter your email"
          required
        />
      </div>

      {/* 密码输入框 */}
      <div>
        <label htmlFor="password" className="text-sm font-medium">
          Password
        </label>
        <Input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Enter your password"
          required
        />
      </div>

      {/* 错误提示 */}
      {error && (
        <div className="text-sm text-red-500">
          {error}
        </div>
      )}

      {/* 提交按钮 */}
      <Button type="submit" disabled={isLoading} className="w-full">
        {isLoading ? "Loading..." : "Login"}
      </Button>
    </form>
  )
}
```

## 终端命令规范

### Windows 环境
- ✅ **必须使用 Windows CMD/PowerShell 命令**
- ❌ **不要使用 Unix/Linux 命令**（如 ls, cat, rm 等）

### 常用命令对照表

| 操作 | ❌ Unix/Linux | ✅ Windows CMD | ✅ PowerShell |
|------|--------------|---------------|--------------|
| 列出文件 | `ls` | `dir` | `Get-ChildItem` 或 `ls` |
| 查看文件 | `cat file.txt` | `type file.txt` | `Get-Content file.txt` |
| 删除文件 | `rm file.txt` | `del file.txt` | `Remove-Item file.txt` |
| 删除目录 | `rm -rf dir/` | `rmdir /s /q dir` | `Remove-Item -Recurse -Force dir` |
| 复制文件 | `cp src dst` | `copy src dst` | `Copy-Item src dst` |
| 移动文件 | `mv src dst` | `move src dst` | `Move-Item src dst` |
| 创建目录 | `mkdir dir` | `mkdir dir` | `New-Item -ItemType Directory dir` |
| 查找进程 | `ps aux \| grep node` | `tasklist \| findstr node` | `Get-Process \| Where-Object {$_.Name -like "*node*"}` |
| 杀死进程 | `kill -9 PID` | `taskkill /F /PID PID` | `Stop-Process -Id PID -Force` |
| 查看端口 | `netstat -tulpn` | `netstat -ano` | `Get-NetTCPConnection` |
| 设置环境变量 | `export VAR=value` | `set VAR=value` | `$env:VAR="value"` |
| 清屏 | `clear` | `cls` | `Clear-Host` 或 `cls` |
| 当前目录 | `pwd` | `cd` | `Get-Location` 或 `pwd` |
| 命令历史 | `history` | `doskey /history` | `Get-History` 或 `h` |

### 正确示例 ✅

```powershell
# 安装依赖
npm install

# 启动开发服务器
npm run dev

# 清理构建缓存（PowerShell）
Remove-Item -Recurse -Force .next
Remove-Item -Recurse -Force node_modules\.cache

# 或使用 CMD
rmdir /s /q .next
rmdir /s /q node_modules\.cache

# 查看 Supabase 状态
supabase status

# 查看运行中的 Node 进程
tasklist | findstr node

# 或使用 PowerShell
Get-Process | Where-Object {$_.Name -like "*node*"}
```

### 错误示例 ❌

```bash
# ❌ 不要使用 Unix 命令
rm -rf .next
ls -la
cat package.json
ps aux | grep node
kill -9 1234
```

### 开发服务器启动规范

**在运行 `npm run dev` 之前，必须先关闭 3000 端口**

#### 方法 1: 查找并关闭端口进程（PowerShell）
```powershell
# 1. 查找占用 3000 端口的进程
netstat -ano | findstr :3000

# 2. 根据 PID 关闭进程
taskkill /F /PID <PID>

# 或使用 PowerShell 一键关闭
Get-NetTCPConnection -LocalPort 3000 -ErrorAction SilentlyContinue | ForEach-Object { Stop-Process -Id $_.OwningProcess -Force }

# 3. 启动开发服务器
npm run dev
```

#### 方法 2: 使用自动化脚本

创建 `scripts/start-dev.ps1`：
```powershell
# 关闭 3000 端口
Write-Host "Checking port 3000..." -ForegroundColor Yellow
$process = Get-NetTCPConnection -LocalPort 3000 -ErrorAction SilentlyContinue
if ($process) {
    Write-Host "Closing port 3000..." -ForegroundColor Yellow
    Stop-Process -Id $process.OwningProcess -Force
    Write-Host "Port 3000 closed." -ForegroundColor Green
    Start-Sleep -Seconds 1
} else {
    Write-Host "Port 3000 is available." -ForegroundColor Green
}

# 启动开发服务器
Write-Host "Starting development server..." -ForegroundColor Green
npm run dev
```

使用方法：
```cmd
scripts\start-dev.bat
```

#### 方法 3: CMD 命令
```cmd
REM 查找 3000 端口进程
netstat -ano | findstr :3000

REM 关闭进程（替换 <PID> 为实际进程 ID）
taskkill /F /PID <PID>

REM 启动开发服务器
npm run dev
```

## 文档编写规范

### 基本原则
- ❌ **不要主动创建文档**，除非用户明确要求
- ✅ **所有文档必须放在 `docs/` 目录**
- ✅ 文档文件名使用 `kebab-case.md` 格式
- ✅ 文档内容可以使用中文或英文，根据用户需求决定

### 不要创建的文档类型（除非用户要求）
- ❌ README.md（项目已有）
- ❌ API 文档
- ❌ 使用指南
- ❌ 开发日志
- ❌ 更新日志 (CHANGELOG.md)
- ❌ 贡献指南 (CONTRIBUTING.md)

### 允许创建的情况
1. **用户明确要求**：
   - "写一个 XX 功能的文档"
   - "创建一个使用说明"
   - "帮我生成 API 文档"

2. **代码注释优先**：
   - 复杂逻辑用注释说明，不需要单独文档
   - 函数说明用 JSDoc/TSDoc 注释
   - 组件说明用内联注释

### 文档存放位置

```
D:\FinCRM\
├── docs/                    # ✅ 所有文档放这里
│   ├── api/                # API 文档
│   │   ├── authentication.md
│   │   └── user-management.md
│   ├── guides/             # 使用指南
│   │   ├── getting-started.md
│   │   └── deployment.md
│   ├── architecture/       # 架构文档
│   │   └── system-design.md
│   └── development/        # 开发文档
│       └── coding-standards.md
├── README.md               # ✅ 项目根目录（已存在）
├── CHANGELOG.md            # ✅ 项目根目录（如需要）
└── ...
```

### 正确流程示例

**场景 1：用户未要求创建文档** ✅
```
用户："帮我实现用户登录功能"
AI：
1. 创建组件代码
2. 添加代码注释
3. ❌ 不创建额外的文档
```

**场景 2：用户明确要求文档** ✅
```
用户："实现登录功能，并写一个使用文档"
AI：
1. 创建组件代码
2. 创建 docs/guides/login-guide.md
3. 在文档中说明使用方法
```

**场景 3：复杂功能说明** ✅
```
用户："这个组件太复杂了，说明一下"
AI：
1. 在代码中添加详细注释
2. 如果注释不够，再询问是否需要创建文档
3. 用户同意后，创建 docs/components/component-name.md
```

## 项目特定规范

### 目录结构约定
```
D:\FinCRM\
├── app/                # Next.js App Router 页面
├── components/         # React 组件
├── lib/               # 工具函数和库
├── docs/              # ✅ 文档目录（新建文档放这里）
├── supabase/          # Supabase 配置和迁移
├── public/            # 静态资源
└── scripts/           # 脚本文件
```

### Git 提交规范
- 提交信息使用英文
- 格式：`type: description`
- 常用类型：
  - `feat`: 新功能
  - `fix`: 修复 bug
  - `docs`: 文档更新
  - `style`: 代码格式调整
  - `refactor`: 代码重构
  - `test`: 测试相关
  - `chore`: 构建或辅助工具更改

#### ⚠️ 重要提醒
- ✅ **每次修复问题或完成功能后，必须及时提交代码**
- ✅ 提交前确保代码可以正常运行
- ✅ 提交信息要清晰描述所做的改动
- ✅ 避免积累太多改动才提交

### 示例
```bash
# ✅ 正确
git commit -m "feat: add user login component"
git commit -m "fix: resolve authentication token issue"
git commit -m "docs: update API documentation"

# ❌ 错误
git commit -m "添加登录功能"
git commit -m "修复了一些bug"
```

## 数据库开发规范

### 开发阶段 vs 生产阶段

#### 开发阶段（推荐做法）✅

**原则**：数据不重要，快速迭代优先

- ✅ **直接修改 SQL 文件**（`supabase/migrations/*.sql`）
- ✅ **修改种子数据**（`supabase/seed.sql`）
- ✅ **完全重置数据库**，不创建新的迁移文件
- ✅ 使用 `supabase db reset` 清空并重新初始化

**操作流程**：
```powershell
# 1. 修改现有 SQL 文件（如 001_initial_schema.sql）
# 2. 修改种子数据（如有需要）
# 3. 重置数据库
supabase db reset

# 确认重置（会清空所有数据）
# 输入 'y' 确认
```

**优点**：
- 🚀 快速迭代，无需管理复杂的迁移历史
- 🧹 保持迁移文件简洁，易于理解
- 🔄 随时可以从头开始，避免迁移冲突

**注意事项**：
- ⚠️ 重置会清空所有测试数据
- ⚠️ 需要重新创建测试用户
- ⚠️ 仅适用于本地开发环境

#### 生产阶段（必须遵循）⚠️

**原则**：保护用户数据，可追溯变更

- ✅ **创建新的迁移文件**（递增编号）
- ✅ **只允许向前迁移**（additive changes）
- ❌ **禁止修改已部署的迁移文件**
- ❌ **禁止使用 db reset**（会删除用户数据）

**操作流程**：
```powershell
# 1. 创建新的迁移文件
supabase migration new add_user_avatar_column

# 2. 编写迁移 SQL
# supabase/migrations/20240101000000_add_user_avatar_column.sql

# 3. 测试迁移
supabase db reset  # 本地测试

# 4. 部署到生产
supabase db push  # 应用到远程数据库
```

### 常用数据库命令

```powershell
# 重置本地数据库（开发阶段）
supabase db reset

# 查看数据库状态
supabase status

# 生成 TypeScript 类型（在修改表结构后）
supabase gen types typescript --local > lib/supabase/types.ts

# 推送到远程数据库（生产环境）
supabase db push

# 从远程拉取迁移
supabase db pull
```

### 迁移文件命名规范

```
supabase/migrations/
├── 001_initial_schema.sql           # 初始数据库架构
├── 002_supplementary_tables.sql     # 补充表
├── 003_auto_create_profile.sql      # 自动创建 profile 触发器
└── 004_add_new_feature.sql          # 新功能（如需要）
```

### 种子数据规范

在 `supabase/seed.sql` 中添加测试数据：

```sql
-- 插入测试用户（开发环境）
INSERT INTO profiles (id, email, first_name, last_name, role)
VALUES 
  ('uuid-1', 'admin@example.com', 'Admin', 'User', 'Admin'),
  ('uuid-2', 'user@example.com', 'Test', 'User', 'User')
ON CONFLICT (id) DO NOTHING;
```

### 开发工作流总结

```powershell
# 典型的开发流程
# 1. 修改数据库架构
# 编辑 supabase/migrations/001_initial_schema.sql

# 2. 修改种子数据（可选）
# 编辑 supabase/seed.sql

# 3. 重置数据库
supabase db reset

# 4. 更新 TypeScript 类型
supabase gen types typescript --local > lib/supabase/types.ts

# 5. 重启开发服务器
npm run dev:safe
```

## Dialog 对话框规范

### 基本原则

**核心规则** ⚠️：
- ✅ **所有操作按钮必须始终可见**
- ✅ **长表单对话框：按钮固定在顶部（使用 sticky positioning）**
- ❌ **禁止将按钮放在长表单底部**（用户需要滚动才能看到）
- ✅ **智能选择全屏模式**（根据表单复杂度）

### 规范分类

根据表单复杂度，Dialog 分为两类：

| 类型 | 适用场景 | 布局方式 | 按钮位置 | 全屏模式 |
|-----|---------|---------|---------|---------|
| **简单 Dialog** | ≤ 5 个字段 | 标准模式 | 底部（DialogFooter） | 不需要 |
| **复杂 Dialog** | > 10 个字段 | Flex 布局 + Sticky | 顶部固定区域 | 推荐使用 |

---

## 简单 Dialog 规范

### 适用场景
- 字段数量 ≤ 5 个
- 表单内容不需要滚动
- 快速输入和确认

### 实现要点
```typescript
<Dialog>
  <DialogContent className="max-w-md">
    <DialogHeader>
      <DialogTitle>Simple Form</DialogTitle>
      <DialogDescription>Quick input form</DialogDescription>
    </DialogHeader>
    
    <form onSubmit={handleSubmit}>
      {/* 简单表单内容 */}
      <div className="space-y-4">
        <Input name="name" />
        <Input name="email" />
      </div>
    </form>
    
    {/* 按钮在底部 - 简单表单可以接受 */}
    <DialogFooter>
      <Button variant="outline" onClick={onClose}>Cancel</Button>
      <Button type="submit">Submit</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

---

## 复杂 Dialog 规范

### 适用场景
对于数据库中字段较多的表（超过 10 个字段），应使用全屏对话框模式，并实现数据持久化功能。

### 必须实现的功能

#### 1. 全屏显示模式和固定顶部布局
- ✅ 对话框支持全屏和标准模式切换
- ✅ 默认使用全屏模式，适合字段多的表单
- ✅ 提供切换按钮，允许用户选择显示模式
- ✅ **所有操作按钮固定在顶部右上角**
- ✅ **滚动内容时按钮始终可见**

**实现示例**：
```typescript
const [isFullscreen, setIsFullscreen] = useState(true)

<DialogContent 
  className={`${
    isFullscreen 
      ? "w-screen h-screen max-w-none max-h-none m-0 rounded-none" 
      : "max-w-4xl max-h-[90vh]"
  } flex flex-col p-0`}
>
  {/* 固定的顶部标题和按钮区域 */}
  <div className="sticky top-0 z-10 bg-background border-b px-6 py-4">
    <DialogHeader className="flex-row items-start justify-between space-y-0">
      <div className="flex-1 pr-4">
        <DialogTitle>Title</DialogTitle>
        <DialogDescription>Description</DialogDescription>
      </div>
      
      {/* 右上角按钮区域 - 始终可见 */}
      <div className="flex gap-2 shrink-0">
        <Button size="sm">Action</Button>
        <Button size="sm" onClick={() => setIsFullscreen(!isFullscreen)}>
          <Maximize2 className="h-4 w-4" />
        </Button>
      </div>
    </DialogHeader>
  </div>

  {/* 可滚动的内容区域 */}
  <div className="flex-1 overflow-y-auto px-6 py-4">
    {/* 表单内容 */}
  </div>
</DialogContent>
```

#### 2. 数据持久化功能
- ✅ 使用 `localStorage` 保存表单草稿
- ✅ 关闭对话框后，数据不会丢失
- ✅ 重新打开对话框时，自动恢复之前输入的数据
- ✅ 成功提交后，自动清除草稿数据

**实现要点**：
```typescript
// 定义存储 key
const DRAFT_STORAGE_KEY = "form_name_draft"

// 保存草稿
function saveDraft(data: FormValues) {
  localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(data))
}

// 加载草稿
function loadDraft() {
  const saved = localStorage.getItem(DRAFT_STORAGE_KEY)
  return saved ? JSON.parse(saved) : null
}

// 清除草稿
function clearDraft() {
  localStorage.removeItem(DRAFT_STORAGE_KEY)
}
```

#### 3. 自动保存功能
- ✅ 监听表单变化，自动保存草稿
- ✅ 使用防抖（debounce）机制，避免频繁保存
- ✅ 仅在新建模式下启用自动保存（编辑模式不需要）

**实现示例**：
```typescript
useEffect(() => {
  if (!editMode && dialogOpen) {
    const subscription = form.watch((value) => {
      const timeoutId = setTimeout(() => {
        saveDraft(value as FormValues)
      }, 1000) // 1秒防抖
      return () => clearTimeout(timeoutId)
    })
    return () => subscription.unsubscribe()
  }
}, [form, editMode, dialogOpen])
```

#### 4. 手动操作按钮
- ✅ **Save Draft**: 手动保存当前表单数据（仅新建模式）
- ✅ **Clear Form**: 清空所有表单数据和草稿（仅新建模式）
- ✅ **Submit Button**: 提交表单的主要按钮（Create/Update）
- ✅ **Maximize Toggle**: 切换全屏模式
- ✅ **所有按钮固定在顶部右上角区域**
- ✅ **使用 sticky 定位确保滚动时始终可见**
- ❌ **不要添加取消按钮**（用户可以点击对话框外部或 ESC 键关闭）

**按钮排列顺序（从左到右）**：
1. Save Draft（仅新建模式）
2. Clear Form（仅新建模式）
3. Submit Button（Create/Update）
4. Maximize Toggle

**UI 布局示例**：
```typescript
{/* 固定顶部区域 */}
<div className="sticky top-0 z-10 bg-background border-b px-6 py-4">
  <DialogHeader className="flex-row items-start justify-between space-y-0">
    <div className="flex-1 pr-4">
      <DialogTitle>Create New Item</DialogTitle>
      <DialogDescription>Fill in the details...</DialogDescription>
    </div>
    
    {/* 右上角按钮区域 - 始终可见 */}
    <div className="flex gap-2 shrink-0">
      {!editMode && (
        <>
          <Button variant="outline" size="sm" onClick={handleSaveDraft} title="Save Draft">
            <Save className="h-4 w-4 mr-2" />
            Save Draft
          </Button>
          <Button variant="outline" size="sm" onClick={handleClearForm} title="Clear Form">
            <Trash2 className="h-4 w-4 mr-2" />
            Clear Form
          </Button>
        </>
      )}
      <Button type="submit" size="sm" form="form-id" title="Create Item">
        Create
      </Button>
      <Button variant="ghost" size="sm" onClick={() => setIsFullscreen(!isFullscreen)} 
              title={isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen"}>
        <Maximize2 className="h-4 w-4" />
      </Button>
    </div>
  </DialogHeader>
</div>

{/* 表单区域 */}
<form id="form-id" onSubmit={handleSubmit}>
  {/* 表单内容 */}
</form>
```

#### 5. 用户提示
- ✅ 恢复草稿时，显示提示信息
- ✅ 保存草稿成功后，显示确认提示
- ✅ 清空表单前，最好有确认提示
- ✅ 在表单底部显示自动保存提示

**提示示例**：
```typescript
// 恢复草稿提示
toast({
  title: "Draft Restored",
  description: "Your previous draft has been restored",
})

// 底部提示文本
<div className="text-sm text-muted-foreground">
  * Your changes are automatically saved as draft
</div>
```

### 完整实现参考

参见 `components/products/product-dialog.tsx` 获取完整实现示例。

### 关键特性清单

对于复杂表单对话框，必须包含以下特性：

**布局和显示**
- [ ] 全屏显示模式（可切换）
- [ ] 固定顶部按钮区域（sticky positioning）
- [ ] 所有操作按钮在顶部右上角（包括提交按钮）
- [ ] 滚动内容时按钮始终可见
- [ ] 使用 flex 布局分离固定区和滚动区
- [ ] 不添加取消按钮（用户可点击外部关闭）
- [ ] 表单使用 id 属性，提交按钮使用 form 属性关联

**数据持久化**
- [ ] localStorage 数据持久化
- [ ] 自动保存草稿（防抖）
- [ ] 手动保存草稿按钮
- [ ] 清空表单按钮
- [ ] 草稿恢复提示
- [ ] 成功提交后清除草稿
- [ ] 仅新建模式启用草稿功能
- [ ] 编辑模式加载现有数据

**用户体验**
- [ ] 按钮添加 title 属性显示提示
- [ ] 使用图标增强可识别性
- [ ] 底部显示自动保存提示文本
- [ ] 提交按钮文字简洁（Create/Update 而非 Create Item/Update Item）
- [ ] 按钮顺序：辅助操作 → 主要操作 → 工具操作

### 注意事项

1. **隐私数据**: 不要在 localStorage 中保存敏感信息（如密码、支付信息）
2. **存储限制**: localStorage 有 5-10MB 限制，注意数据大小
3. **清理策略**: 成功提交后必须清除草稿，避免数据混乱
4. **编辑模式**: 编辑现有数据时，不使用草稿功能
5. **测试**: 确保关闭/重开对话框能正确恢复数据
6. **布局结构**: 使用 `flex flex-col p-0` 在 DialogContent 上，分离固定区和滚动区
7. **固定定位**: 使用 `sticky top-0 z-10` 确保顶部区域始终可见
8. **按钮位置**: 所有操作按钮统一放在顶部右上角，使用 `shrink-0` 防止压缩

### 布局要点

**对话框结构**：
```
DialogContent (flex flex-col p-0)
├── 固定顶部区域 (sticky top-0 z-10)
│   ├── 标题和描述 (flex-1)
│   └── 操作按钮组 (shrink-0)
└── 可滚动内容区域 (flex-1 overflow-y-auto)
    └── 表单内容
```

**关键 CSS 类**：
- `DialogContent`: `flex flex-col p-0` - 建立 flex 容器，移除默认 padding
- 顶部区域: `sticky top-0 z-10 bg-background border-b px-6 py-4` - 固定定位
- 按钮容器: `flex gap-2 shrink-0` - 防止按钮被压缩
- 内容区域: `flex-1 overflow-y-auto px-6 py-4` - 可滚动区域

**表单提交关联**：
- 表单添加 `id` 属性：`<form id="product-form">`
- 提交按钮使用 `form` 属性关联：`<Button type="submit" form="product-form">`
- 这样按钮在顶部也能提交表单内容

---

## Dialog 类型快速决策指南

### 如何选择 Dialog 类型？

```
开始
  ↓
表单字段数量？
  ↓
├─ ≤ 5 个字段 → 使用简单 Dialog
│                - 按钮在底部（DialogFooter）
│                - 标准尺寸（max-w-md 或 max-w-lg）
│                - 不需要全屏
│
├─ 6-10 个字段 → 使用中等 Dialog
│                - 按钮在底部或顶部（根据是否需要滚动）
│                - 较大尺寸（max-w-2xl）
│                - 如果内容超过视口高度，考虑顶部固定按钮
│
└─ > 10 个字段 → 使用复杂 Dialog（必须遵循复杂 Dialog 规范）
                 - 按钮固定在顶部（sticky positioning）
                 - 支持全屏模式
                 - 实现草稿保存功能
                 - 表单使用 id + form 属性关联
```

### 按钮位置决策树

```
表单内容是否需要滚动？
  ↓
├─ 否 → 按钮可以放在底部（DialogFooter）
│       ✅ 简单 Dialog 的标准做法
│
└─ 是 → 按钮必须固定在顶部
        ⚠️ 用户不应该滚动到底部才能找到提交按钮
        使用 sticky positioning 确保按钮始终可见
```

### 实际案例对照

| 表单类型 | 字段数量 | Dialog 类型 | 参考组件 |
|---------|---------|------------|---------|
| 登录表单 | 2-3 | 简单 Dialog | - |
| 快速添加联系人 | 3-5 | 简单 Dialog | `contact-dialog.tsx` |
| 客户信息表单 | 8-12 | 复杂 Dialog | `customer-dialog.tsx` |
| 产品信息表单 | 15+ | 复杂 Dialog | `product-dialog.tsx` ✅ 标准实现 |
| 供应商表单 | 10-15 | 复杂 Dialog | `supplier-dialog.tsx` |
| 采购订单表单 | 20+ | 复杂 Dialog | `purchase-order-dialog.tsx` |

### 关键提醒 ⚠️

**永远不要这样做**：
```typescript
// ❌ 错误：长表单，按钮在底部，用户需要滚动才能看到
<DialogContent className="max-h-[90vh] overflow-y-auto">
  <DialogHeader>...</DialogHeader>
  
  {/* 很长的表单内容... 20+ 个字段 */}
  <form>...</form>
  
  {/* ❌ 按钮在底部，用户看不到 */}
  <DialogFooter>
    <Button>Submit</Button>
  </DialogFooter>
</DialogContent>
```

**应该这样做**：
```typescript
// ✅ 正确：长表单，按钮固定在顶部，始终可见
<DialogContent className="flex flex-col p-0">
  {/* 固定在顶部的按钮 */}
  <div className="sticky top-0 z-10 bg-background">
    <DialogHeader>...</DialogHeader>
    <div className="flex gap-2 shrink-0">
      <Button type="submit" form="my-form">Submit</Button>
    </div>
  </div>
  
  {/* 可滚动的表单内容 */}
  <div className="flex-1 overflow-y-auto">
    <form id="my-form">...</form>
  </div>
</DialogContent>
```

### 开发检查清单

创建新的 Dialog 时，请确认：

**对于所有 Dialog**：
- [ ] 确定表单字段数量
- [ ] 选择合适的 Dialog 类型
- [ ] 按钮位置正确（根据是否需要滚动）
- [ ] 添加必要的 aria 标签（可访问性）

**对于复杂 Dialog（> 10 字段）**：
- [ ] 实现全屏模式切换
- [ ] 按钮固定在顶部（sticky positioning）
- [ ] 表单使用 id 属性
- [ ] 提交按钮使用 form 属性关联
- [ ] 实现草稿保存功能
- [ ] 实现草稿恢复功能
- [ ] 添加自动保存（防抖）
- [ ] 测试滚动时按钮是否始终可见
- [ ] 测试关闭/重开对话框草稿是否恢复

---

**记住**：用户体验 > 传统习惯。如果表单需要滚动，不要把按钮放在底部！
